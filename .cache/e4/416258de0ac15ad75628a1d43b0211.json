{"id":"src/scripts/gl/shaders/simulation.frag","dependencies":[{"name":"/Users/minuru/Documents/HECTOR-AI/node_modules/glsl-curl-noise/curl.glsl","includedInParent":true,"mtime":1751386225813},{"name":"/Users/minuru/Documents/HECTOR-AI/node_modules/glsl-noise/classic/3d.glsl","includedInParent":true,"mtime":1751386225938},{"name":"/Users/minuru/Documents/HECTOR-AI/node_modules/glsl-noise/simplex/3d.glsl","includedInParent":true,"mtime":1751386226076},{"name":"/Users/minuru/Documents/HECTOR-AI/package.json","includedInParent":true,"mtime":1721663553000}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform sampler2D positions; // Data Texture containing original positions\\nuniform float uTime;\\nuniform float uSpeed;\\nuniform float uCurlFreq;\\n\\nvarying vec2 vUv;\\n\\n#define PI 3.1415926538\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_1(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_1(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_1(vec4 x) {\\n     return mod289_1(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_1(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289_1(i);\\n  vec4 p = permute_1( permute_1( permute_1(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt_1(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvec3 snoiseVec3( vec3 x ){\\n\\n  float s  = snoise(vec3( x ));\\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\\n  vec3 c = vec3( s , s1 , s2 );\\n  return c;\\n\\n}\\n\\nvec3 curlNoise( vec3 p ){\\n  \\n  const float e = .1;\\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\\n\\n  vec3 p_x0 = snoiseVec3( p - dx );\\n  vec3 p_x1 = snoiseVec3( p + dx );\\n  vec3 p_y0 = snoiseVec3( p - dy );\\n  vec3 p_y1 = snoiseVec3( p + dy );\\n  vec3 p_z0 = snoiseVec3( p - dz );\\n  vec3 p_z1 = snoiseVec3( p + dz );\\n\\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\\n\\n  const float divisor = 1.0 / ( 2.0 * e );\\n  return normalize( vec3( x , y , z ) * divisor );\\n\\n}\\n\\n//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_0(vec3 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_0(vec4 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_0(vec4 x)\\n{\\n  return mod289_0(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_0(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec3 fade(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\n// Classic Perlin noise\\nfloat cnoise(vec3 P)\\n{\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod289_0(Pi0);\\n  Pi1 = mod289_0(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute_0(permute_0(ix) + iy);\\n  vec4 ixy0 = permute_0(ixy + iz0);\\n  vec4 ixy1 = permute_0(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt_0(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt_0(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n  return 2.2 * n_xyz;\\n}\\n\\nmat4 rotation3d(vec3 axis, float angle) {\\n  axis = normalize(axis);\\n  float s = sin(angle);\\n  float c = cos(angle);\\n  float oc = 1.0 - c;\\n\\n  return mat4(\\n\\t\\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n\\t\\t0.0,                                0.0,                                0.0,                                1.0\\n\\t);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\treturn (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\\n}\\n\\nvoid main() {\\n  float t = uTime * 0.15 * uSpeed;\\n\\n  vec2 uv = vUv;\\n\\n  vec3 pos = texture2D(positions, uv).rgb; // basic simulation: displays the particles in place.\\n  vec3 curlPos = texture2D(positions, uv).rgb;\\n  vec3 finalPos = vec3(0.0);\\n\\n  // Move the particles here\\n  // pos = rotate(pos, vec3(0.0, 0.0, 1.0), t + sin(length(pos.xy) * 2.0 + PI * 0.5) * 10.0);\\n  // pos = rotate(pos, vec3(1.0, 0.0, 0.0), -t);\\n  // pos.z += tan(length(length(pos.xy) * 10.0) - t) * 1.0;\\n  pos = curlNoise(pos * uCurlFreq + t);\\n\\n  curlPos = curlNoise(curlPos * uCurlFreq + t);\\n  // if you uncomment the next noise additions\\n  // you'll get very pleasing flocking particles\\n  // inside the bounds of a sphere\\n  curlPos += curlNoise(curlPos * uCurlFreq * 2.0) * 0.5;\\n  curlPos += curlNoise(curlPos * uCurlFreq * 4.0) * 0.25;\\n  curlPos += curlNoise(curlPos * uCurlFreq * 8.0) * 0.125;\\n  curlPos += curlNoise(pos * uCurlFreq * 16.0) * 0.0625;\\n\\n  finalPos = mix(pos, curlPos, cnoise(pos + t));\\n  \\n  gl_FragColor = vec4(finalPos, 1.0);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":15}},{"generated":{"line":1,"column":9172},"source":"src/scripts/gl/shaders/simulation.frag","original":{"line":1,"column":0}}],"sources":{"src/scripts/gl/shaders/simulation.frag":"module.exports=\"#define GLSLIFY 1\\nuniform sampler2D positions; // Data Texture containing original positions\\nuniform float uTime;\\nuniform float uSpeed;\\nuniform float uCurlFreq;\\n\\nvarying vec2 vUv;\\n\\n#define PI 3.1415926538\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_1(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_1(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_1(vec4 x) {\\n     return mod289_1(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_1(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289_1(i);\\n  vec4 p = permute_1( permute_1( permute_1(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt_1(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvec3 snoiseVec3( vec3 x ){\\n\\n  float s  = snoise(vec3( x ));\\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\\n  vec3 c = vec3( s , s1 , s2 );\\n  return c;\\n\\n}\\n\\nvec3 curlNoise( vec3 p ){\\n  \\n  const float e = .1;\\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\\n\\n  vec3 p_x0 = snoiseVec3( p - dx );\\n  vec3 p_x1 = snoiseVec3( p + dx );\\n  vec3 p_y0 = snoiseVec3( p - dy );\\n  vec3 p_y1 = snoiseVec3( p + dy );\\n  vec3 p_z0 = snoiseVec3( p - dz );\\n  vec3 p_z1 = snoiseVec3( p + dz );\\n\\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\\n\\n  const float divisor = 1.0 / ( 2.0 * e );\\n  return normalize( vec3( x , y , z ) * divisor );\\n\\n}\\n\\n//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_0(vec3 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_0(vec4 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_0(vec4 x)\\n{\\n  return mod289_0(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_0(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec3 fade(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\n// Classic Perlin noise\\nfloat cnoise(vec3 P)\\n{\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod289_0(Pi0);\\n  Pi1 = mod289_0(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute_0(permute_0(ix) + iy);\\n  vec4 ixy0 = permute_0(ixy + iz0);\\n  vec4 ixy1 = permute_0(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt_0(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt_0(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n  return 2.2 * n_xyz;\\n}\\n\\nmat4 rotation3d(vec3 axis, float angle) {\\n  axis = normalize(axis);\\n  float s = sin(angle);\\n  float c = cos(angle);\\n  float oc = 1.0 - c;\\n\\n  return mat4(\\n\\t\\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n\\t\\t0.0,                                0.0,                                0.0,                                1.0\\n\\t);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\treturn (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\\n}\\n\\nvoid main() {\\n  float t = uTime * 0.15 * uSpeed;\\n\\n  vec2 uv = vUv;\\n\\n  vec3 pos = texture2D(positions, uv).rgb; // basic simulation: displays the particles in place.\\n  vec3 curlPos = texture2D(positions, uv).rgb;\\n  vec3 finalPos = vec3(0.0);\\n\\n  // Move the particles here\\n  // pos = rotate(pos, vec3(0.0, 0.0, 1.0), t + sin(length(pos.xy) * 2.0 + PI * 0.5) * 10.0);\\n  // pos = rotate(pos, vec3(1.0, 0.0, 0.0), -t);\\n  // pos.z += tan(length(length(pos.xy) * 10.0) - t) * 1.0;\\n  pos = curlNoise(pos * uCurlFreq + t);\\n\\n  curlPos = curlNoise(curlPos * uCurlFreq + t);\\n  // if you uncomment the next noise additions\\n  // you'll get very pleasing flocking particles\\n  // inside the bounds of a sphere\\n  curlPos += curlNoise(curlPos * uCurlFreq * 2.0) * 0.5;\\n  curlPos += curlNoise(curlPos * uCurlFreq * 4.0) * 0.25;\\n  curlPos += curlNoise(curlPos * uCurlFreq * 8.0) * 0.125;\\n  curlPos += curlNoise(pos * uCurlFreq * 16.0) * 0.0625;\\n\\n  finalPos = mix(pos, curlPos, cnoise(pos + t));\\n  \\n  gl_FragColor = vec4(finalPos, 1.0);\\n}\";"},"lineCount":null}},"error":null,"hash":"3d2beab9b7083893bd9613800b03f1ac","cacheData":{"env":{}}}